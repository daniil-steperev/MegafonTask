# Задание отборочного этапа школы Мегафона
### Описание задачи:
Реализовать игру «Жизнь» с выводом состояния поля в консоль при каждой итерации. Условия:
* инициализировать поле начальным состоянием;
* используя указанные правила, реализовать автомат;
* вместо вывода в консоль можно использовать библиотеку графики.
* язык программирования -- любой.

### Описание используемых технологий:
В проекте были использованы следующие технологии:
* язык программирования -- Java;
* графическая библиотека -- JavaFX;
* графическая библиотека JavaRush;

### Как запустить приложение в среде IntelliJ IDEA:
Запустить класс GameApplication.
Если приложение не удается собрать, необходимо подключить библиотеку. Сделать это можно следующим способом:
1. File -> Project Structure.
2. На вкладке Project Settings выбрать пункт Libraries.
3. Нажать на ___+___ и выбрать lib/desktop-game-engine.jar. Нажать на __ОК__.
4. Выбрать все модули и нажать __ОК__.

Краткая GIF-картинка как это можно сделать:
![Alt Text](https://media.giphy.com/media/J0oD4IXlzBao5M8Ihq/source.gif)

### Демонстрация работы приложения:
Небольшая анимация, демонстрирующая работу приложения:
![Alt Text](https://media.giphy.com/media/E1bLdJXF9hUx9DHwsN/giphy.gif)

### Описание работы приложения:
1. Создается первоначальный *клеточный организм*.
2. Начинается *смена поколений* по правилам, описанным для Conway's Game of Life.
3. Смена поколений будет продолжаться до тех пор, пока:
   a) не закончатся все клетки;
   б) *клеточный организм* не стабилизируется (то есть когда новые клетки не будут *зарождаться*, а старые *умирать*).
4. В случае наступления любого условия из пункта 3 пользователь получает оповещение, что игра закончилась. При нажатии на __SPACE__ можно возобновить игру.
5. Табло _Score_ отображает количество живых клеток текущего поколения.

### Некоторые хитрости реализации:
1. Хранятся только *живые* клетки. При работе приложения было замечено, что число *живых* клеток зачастую меньше, чем *погибших*. В связи с этим, нет необходимости хранить все клетки, так как одно множество можно получить, как дополнение второго.
2. Само хранение *живых* клеток происходит не в списке, а в хэш-таблице. Это было сделано для ускорения работы программы. Так как общее число клеток остается фиксированным (40 * 40 штук), то при правильном составлении хэш-функции можно добиться очень быстрой скорости получения нужного элемента (или, как в нашем случае, проверки, есть ли элемент в таблице). Хэш-функция была составлена примитивным образом: умножаем номер столбца на константу и прибавляем номер строки. Коллизии не возникнет, потому что константа была подобрана таким образом. Благодаря этому ухищрению, удалось добиться скорости поиска элемента в O(1).
